package schema

import (
	"fmt"
	"github.com/civet148/gotools/log"
	"github.com/civet148/sqlca"
	"os"
	"strings"
)

const (
	METHOD_ARGS_NULL     = ""
	METHOD_NAME_STRING   = "String"
	METHOD_NAME_GOSTRING = "GoString"
	METHOD_NAME_GET      = "Get"
	METHOD_NAME_SET      = "Set"
)

func ExportTableSchema(cmd *Commander, tables []*TableSchema) (err error) {

	for _, v := range tables {

		_, errStat := os.Stat(cmd.OutDir)
		if errStat != nil && os.IsNotExist(errStat) {

			log.Info("mkdir [%v]", cmd.OutDir)
			if err = os.Mkdir(cmd.OutDir, os.ModeDir); err != nil {
				log.Error("mkdir [%v] error (%v)", cmd.OutDir, err.Error())
				return
			}
		}

		v.OutDir = cmd.OutDir

		if cmd.PackageName == "" {
			//mkdir by output dir + scheme name
			cmd.PackageName = v.SchemeName
			if strings.LastIndex(cmd.OutDir, fmt.Sprintf("%v", os.PathSeparator)) == -1 {
				v.SchemeDir = fmt.Sprintf("%v/%v", cmd.OutDir, cmd.PackageName)
			} else {
				v.SchemeDir = fmt.Sprintf("%v%v", cmd.OutDir, cmd.PackageName)
			}
		} else {
			v.SchemeDir = fmt.Sprintf("%v/%v", cmd.OutDir, cmd.PackageName) //mkdir by package name
		}

		_, errStat = os.Stat(v.SchemeDir)

		if errStat != nil && os.IsNotExist(errStat) {

			log.Info("mkdir [%v]", v.SchemeDir)
			if err = os.Mkdir(v.SchemeDir, os.ModeDir); err != nil {
				log.Errorf("mkdir path name [%v] error (%v)", v.SchemeDir, err.Error())
				return
			}
		}

		var strPrefix, strSuffix string
		if cmd.Prefix != "" {
			strPrefix = fmt.Sprintf("%v_", cmd.Prefix)
		}
		if cmd.Suffix != "" {
			strSuffix = fmt.Sprintf("_%v", cmd.Suffix)
		}

		v.FileName = fmt.Sprintf("%v/%v%v%v.go", v.SchemeDir, strPrefix, v.TableName, strSuffix)
		if err = ExportTableColumns(cmd, v); err != nil {
			return
		}
	}

	return
}

func ExportTableColumns(cmd *Commander, table *TableSchema) (err error) {

	var File *os.File
	File, err = os.OpenFile(table.FileName, os.O_CREATE|os.O_RDWR|os.O_TRUNC, 0)
	if err != nil {
		log.Errorf("open file [%v] error (%v)", table.FileName, err.Error())
		return
	}
	log.Infof("exporting table schema [%v] to file [%v]", table.TableName, table.FileName)

	var strHead, strContent string

	//write package name
	strHead += fmt.Sprintf("// Code generated by db2go. DO NOT EDIT.\n")
	strHead += fmt.Sprintf("// https://github.com/civet148/sqlca\n")
	strHead += fmt.Sprintf("\n")
	strHead += fmt.Sprintf("package %v\n\n", cmd.PackageName)

	//write table name in camel case naming
	table.TableNameCamelCase = CamelCaseConvert(table.TableName)
	table.TableComment = ReplaceCRLF(table.TableComment)
	strContent += fmt.Sprintf("var TableName%v = \"%v\" //%v \n\n", table.TableNameCamelCase, table.TableName, table.TableComment)

	table.StructName = fmt.Sprintf("%s%s", table.TableNameCamelCase, strings.ToUpper(cmd.Suffix))

	for i, v := range table.Columns {
		table.Columns[i].Comment = ReplaceCRLF(v.Comment)
	}
	if cmd.Orm || (haveDecimal(table, table.Columns) && cmd.EnableDecimal) {
		strHead += IMPORT_SQLCA + "\n\n" //根据数据库中是否存在decimal类型决定是否导入sqlca包
	}

	strContent += makeColumnConsts(cmd, table)
	strContent += makeTableStructure(cmd, table)
	strContent += makeNewMethod(cmd, table)
	strContent += makeObjectMethods(cmd, table)
	strContent += makeOrmMethods(cmd, table)
	strContent += makeTableCreateSQL(cmd, table)
	_, _ = File.WriteString(strHead + strContent)
	return
}

func haveDecimal(table *TableSchema, TableCols []TableColumn) (ok bool) {
	for _, v := range TableCols {
		_, ok = GetGoColumnType(table.TableName, v, false)
		if ok {
			break
		}
	}
	return
}

func makeNewMethod(cmd *Commander, table *TableSchema) (strContent string) {
	if cmd.Orm {
		strContent += fmt.Sprintf(`
func New%v(db *sqlca.Engine) *%v {
	return &%v{
		_db_: db,
	}
}

`, table.StructName, table.StructName, table.StructName)
	}
	return
}

func makeObjectMethods(cmd *Commander, table *TableSchema) (strContent string) {

	for _, v := range table.Columns { //添加结构体成员Get/Set方法

		if IsInSlice(v.Name, cmd.Without) {
			continue
		}
		strColName := CamelCaseConvert(v.Name)
		strColType, _ := GetGoColumnType(table.TableName, v, cmd.EnableDecimal)
		strContent += MakeGetter(table.StructName, strColName, strColType)
		strContent += MakeSetter(table.StructName, strColName, strColType)
	}
	return
}

func makeTableCreateSQL(cmd *Commander, table *TableSchema) (strContent string) {
	strContent += "/*\n"
	strContent += table.TableCreateSQL + ";\n"
	strContent += "*/\n"
	return
}

func makeOrmMethods(cmd *Commander, table *TableSchema) (strContent string) {
	if cmd.Orm {
		strContent += makeOrmInsertMethod(cmd, table)
		strContent += makeOrmUpsertMethod(cmd, table)
		strContent += makeOrmUpdateMethod(cmd, table)
		strContent += makeOrmQueryMethod(cmd, table)
		strContent += makeOrmQueryExcludeMethod(cmd, table)
	}
	return
}

func makeOrmInsertMethod(cmd *Commander, table *TableSchema) (strContent string) {
	return fmt.Sprintf(`
//insert into table by data model
func (do *%v) Insert_() (lastInsertId int64, err error) {
	return do._db_.Model(do).Table(%v).Insert()
}
`, table.StructName, table.TableNameCamelCase)
}

func makeOrmUpsertMethod(cmd *Commander, table *TableSchema) (strContent string) {
	return fmt.Sprintf(`
//insert if not exist or update columns on duplicate key...
func (do *%v) Upsert_() (lastInsertId int64, err error) {
	return do._db_.Model(do).Table(%v).Select(columns...).Upsert()
}
`, table.StructName, table.TableNameCamelCase)
}

func makeOrmUpdateMethod(cmd *Commander, table *TableSchema) (strContent string) {
	return fmt.Sprintf(`
//update table set columns where id=xxx
func (do *%v) Update_(columns...string) (rows int64, err error) {
	return do._db_.Model(do).Table(%v).Select(columns...).Update()
}
`, table.StructName, table.TableNameCamelCase)
}

func makeOrmQueryMethod(cmd *Commander, table *TableSchema) (strContent string) {
	return fmt.Sprintf(`
//select columns from table where id=xxx
func (do *%v) Query_(columns...string) (rows int64, err error) {
	return do._db_.Model(do).Table(%v).Select(columns...).Query()
}
`, table.StructName, table.TableNameCamelCase)
}

func makeOrmQueryExcludeMethod(cmd *Commander, table *TableSchema) (strContent string) {
	return fmt.Sprintf(`
//select * from table where id=xxx exclude columns
func (do *%v) Query_exclude(columns...string) (rows int64, err error) {
	return do._db_.Model(do).Table(%v).Exclude(columns...).Query()
}
`, table.StructName, table.TableNameCamelCase)
}

func makeColumnConsts(cmd *Commander, table *TableSchema) (strContent string) {
	var strUpperTableName string
	var strUpperColumnName string
	strUpperTableName = strings.ToUpper(table.TableName)

	strContent += fmt.Sprintf("var (\n")
	for _, v := range table.Columns {
		strUpperColumnName = strings.ToUpper(v.Name)
		strContent += fmt.Sprintf("%s_%s_%s = \"%s\"\n", strUpperTableName, "COLUMN", strUpperColumnName, v.Name)
	}
	strContent += fmt.Sprintf(")\n\n")
	return
}
func makeTableStructure(cmd *Commander, table *TableSchema) (strContent string) {

	strContent += fmt.Sprintf("type %v struct { \n", table.StructName)

	if cmd.Orm {
		strContent += "_db_      *sqlca.Engine \n"
	}
	for _, v := range table.Columns {

		if IsInSlice(v.Name, cmd.Without) {
			continue
		}

		var tagValues []string
		var strColType, strColName string
		strColName = CamelCaseConvert(v.Name)
		strColType, _ = GetGoColumnType(table.TableName, v, cmd.EnableDecimal)

		if IsInSlice(v.Name, cmd.ReadOnly) {
			tagValues = append(tagValues, fmt.Sprintf("%v:\"%v\"", sqlca.TAG_NAME_SQLCA, sqlca.SQLCA_TAG_VALUE_READ_ONLY))
		}
		for _, t := range cmd.Tags {
			tagValues = append(tagValues, fmt.Sprintf("%v:\"%v\"", t, v.Name))
		}
		//添加成员和标签
		strContent += MakeTags(strColName, strColType, v.Name, v.Comment, strings.Join(tagValues, " "), cmd.OmitEmpty)

		v.GoName = strColName
		v.GoType = strColType
	}

	strContent += "}\n\n"

	return
}

func GenerateMethodDeclare(strShortName, strStructName, strMethodName, strArgs, strReturn, strLogic string) (strFunc string) {
	if strReturn == "" {
		strFunc = fmt.Sprintf("func (%s *%s) %s(%s) {\n", strShortName, strStructName, strMethodName, strArgs)
	} else {
		strFunc = fmt.Sprintf("func (%s *%s) %s(%s) %s {\n", strShortName, strStructName, strMethodName, strArgs, strReturn)
	}
	strFunc += strLogic
	strFunc += fmt.Sprintf("}\n\n")
	return
}
